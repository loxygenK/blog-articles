---
title: "過激な思想: 私が Go より Rust が好きな理由"
subTitle: "Controversial Opinion: The reason why I love Rust over Go"
type: "programming"
date: 2024-01-13
published: true
---

ブログができたので、さっそく私の :sparkles: 過激思想 :sparkles: をぶつけようと思います。

# 私の意見です

明示します ― **これは私の個人的な意見です!** ここに書かれていることを推奨しているわけでもなく、
ただ単に私個人の意見なだけです。この記事を読んで Rust を使う必要もないですし、Go をやめる必要もありません。
個人の方々が好き/使いやすい/使いたい/...ものを自由に使うべきです。

…… 一方で、後述するように、どうも私にとって Go は難しいと感じてしまい、あまり好きになれません。
愛する人がいるのも理解できます! でなければこんなにメジャーな言語になってないと思いますし。

### 私の立場について

過激思想を喋る上で、私がどのような背景事情やキャリアを持ってして喋ってるのかは明確にしたほうがよいかと思うので、明確にします。

私はフロントエンドエンジニアです! 普段は TypeScript で Next.js を使って Web サイトを作っています。
そして私は Rust が大好きです。といってもサーバーサイドアプリケーションやシステムアプリケーションを作った経験はありません。

Go にもあまり造形が深くありません。ただ、Go を触ってる人が嘆いてるのを見たことはあります。

-----

# TL:DR

- **Go はコード書いて動かすのはめちゃくちゃ簡単だけど、その後すごい苦労すると思います**
- **Rust はコード書いて動かすのはめちゃくちゃ苦労するけど、その後は比較的楽だと思います**
- コードを書いて動かすのを重視するか、その後も重視するかはケースバイケースだと思います
  - が、だいたいソフトウェアって保守されるからそういう意味では Go って大変じゃないかな〜〜〜! というのが、私の正直な意見です!

以降はそれの裏付けというか、私のロジックです。


# 前提: Go と Rust は得意分野が違う

Go は簡単だ、Rust は難しい、というと、**全観点を一つの言葉にひっくるめて難易度について言及してしまっている**ような感じになってしまいます。
ここを分割して、Go が †完全悪† じゃない、Rust も †聖なる言語† でもない、ということを理解しようと思います。

# Rust は「動かすところまでは大変」、でも「そこからは比較的楽」

Rust には所有権とかライフタイムとか、そういうユニーク[^not-unique] なルールが存在しています。
しかもそれを守らないとコンパイルが落ちるしそのコンパイルエラーも長い。コンパイルエラーが数十行を超えることはざらにあります。

そういうわけで、**コンパイルが通って動くようになるまではそれなりに時間がかかります**。

ですが一方で、**怪しいコードはコンパイルタイムで全力で弾かれてるので、そのコードがプロダクションに上がるときそれは怪しいコードじゃない**というのもあります。
なので、後から……

- 「は〜〜〜？な〜〜〜んでここそんなデータの変わり方するわけ〜〜〜〜？？？？？」とか、
- 「は〜〜〜〜〜？？？ Null dereference 〜〜〜〜〜〜？どっから来たその nil？？？？？？？？？？？」

みたいな、プログラマさんの Typo 等に寄らない、ランタイムやコンピュータの特性などに起因するようなトラックしにくいバグが格段に減る、、はずです。
事前にチェックされているので!

コードを書いてそれを動かすまでにコストは長くかかりますが、将来のバグつぶしタイムが前借りされていると考えることもできます。

[^not-unique]: 所有権とかが「独自」のものではない、というのは理解しています。便宜上一応「ユニーク」と言っています。TypeScript とか Python とかにはビルドインではついていないですし

# Go は「動かすところまではすぐ行ける」、でも「そこからは大変」

これは他の言語にも言えることではありますが、**Go は Go が書ければちゃんと** (動作が期待されたものかは置いておいて) **動きます**。
しかも**構文が超カンタン!** 所有権みたいなのがある Rust とは対照的に、**Go は書けば動くし、書くのも簡単**です。

このように、**コンパイルが通って動くように鳴るまではぱっぱと進むことができます!**

一方で、**気をつけないと大変な Pitfall に足を突っ込んでバグを産んでしまうことになります**。

Go の Null 値/ゼロ値の取り扱い周りはよく聞く印象を持っています。
Go で Nullable な値を表現したいとき、**参照に興味がなくても / 値のみに興味があったとしても**ポインタ型を用いて
`nil` を入れられるようにする必要があったり、値の初期化時にゼロ値というデフォルトが存在したりというところとかです。
こういう、自分の意図とは異なるコードを書く必要がある場面があり、そういうところから Pitfall が生まれてしまいそうな感じもします。

…………というヒステリックな話をしましたが、**書くのが超簡単**という利点は間違いなく大きいとは思います。こういう Pitfall も、
**ちゃんと Go の挙動を理解して意識すれば未然に防ぐことができるかとも思います!**

## Go は、\*気をつければ\*、動かすのもそこからも、それなりに大変じゃなくなるが、気をつける必要がある

`ちゃんと Go の挙動を理解して意識すれば未然に防ぐことができるかとも思います` と申し上げましたが、
これは**気をつけて書かないと後が大変なことになる**ということでもあり、
人間に依存しているところが大きく、そこが崩れると大変なことになる、というのもありえるんじゃないかなあと思っています。
(とはいっても静的解析つよいし人の手に頼らなくてもよいんでしょうか? 詳しい方いたら教えてください。)

そもそも気をつけられるようになるところまで行くのも結局学習コストがありますし、
共同開発にて気をつけない人がチームメンバーにいた場合気をつけられなかったコードが流れてバグの温床になる……ということもあるかもしれません。
**もちろん、`go vet` 回すとか自動テストぶん回すとかで回避できるとは思います!**

# とりあえず動かすのが大事か、その後も大事か

とりあえず動かすのが大事、その後も大事かというのもケースによって違ってくると思います。例えば……

- **めっちゃ簡単な PoC やプロトタイピングで開発ブンブン回したい**ような場合なら「とりあえず」動かすのが大事そうですし、一方で
- **バグがかなり許容できない**場合や**動かせるまでに時間がある**ような場合なら「その後」も重点的に視野に入るかなあと思います。

という感じで、ケースによってどちらの側面、またどちらのプログラミング言語がより適任で重宝されるかは変わってくるような気がします。

# 私としての個人的な意見

以上ができるだけ中立的にまとめてみた、、はずの内容です。全然中立的になってない気もしますが………
この内容を踏まえて、私の私情や価値観を入れた Dirty な意見を述べてみます。

<Section type="opinionated">
  私は、個人開発などのわりかしどうでもいいソフトウェアを作る際にも (自分が思う) 完璧を目指すような傾向があり、
  それが理由で「とりあえず動かす」という判断を取りにくいです。
  これがあるために、私は **Go は基本的に採用できず、Rust を取る**ということが多いです。
  また、個人的な Go ポジとしてすでに Python がいるため、私としては Go の需要が Python に吸われてしまってるというのもあるかもしれません。

  その一方で、業務開発などの場面だと、スケジュールがタイトであまり開発に時間をたんまり書けることができないということも多くあります。
  そのような場合だと、動いているところを見ることができるまでの時間が長いことに対する不安感などから **Rust は採用できず、Go を取る**ということも多いかと思います。市場になかなか Rust が浸透しない理由にもこれがあるかなあと思っています……。
</Section>

# おわりに

個人ブログができたことをいいことに過激思想を喋ってみました。こんなの Zenn とかで喋った日には大変なことになってしまいそうです……… 
一方で、ちゃんといろいろエビデンスを整理して参考文献をいっぱい引っ張り出して、客観的に信頼しやすい情報に磨いていけば Zenn
とかにも普通に出せるかなあとも思うので、そのうちそっちにも出したいなあみたいなことも思っています。

駄文になってしまいましたが、ここまでお読みいただきありがとうございました! より良い表現が見つかったり思想にアップデートがあったりしたときは、
記事を更新しようと思います。
